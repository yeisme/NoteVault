// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/yeisme/notevault/pkg/storage/repository/model"
)

func newFileVersion(db *gorm.DB, opts ...gen.DOOption) fileVersion {
	_fileVersion := fileVersion{}

	_fileVersion.fileVersionDo.UseDB(db, opts...)
	_fileVersion.fileVersionDo.UseModel(&model.FileVersion{})

	tableName := _fileVersion.fileVersionDo.TableName()
	_fileVersion.ALL = field.NewAsterisk(tableName)
	_fileVersion.VersionID = field.NewString(tableName, "version_id")
	_fileVersion.FileID = field.NewString(tableName, "file_id")
	_fileVersion.VersionNumber = field.NewInt32(tableName, "version_number")
	_fileVersion.Size = field.NewInt64(tableName, "size")
	_fileVersion.Path = field.NewString(tableName, "path")
	_fileVersion.ContentType = field.NewString(tableName, "content_type")
	_fileVersion.CreatedAt = field.NewInt64(tableName, "created_at")
	_fileVersion.DeletedAt = field.NewInt64(tableName, "deleted_at")
	_fileVersion.Status = field.NewInt32(tableName, "status")
	_fileVersion.CommitMessage = field.NewString(tableName, "commit_message")

	_fileVersion.fillFieldMap()

	return _fileVersion
}

type fileVersion struct {
	fileVersionDo

	ALL           field.Asterisk
	VersionID     field.String
	FileID        field.String
	VersionNumber field.Int32
	Size          field.Int64
	Path          field.String
	ContentType   field.String
	CreatedAt     field.Int64
	DeletedAt     field.Int64
	Status        field.Int32
	CommitMessage field.String

	fieldMap map[string]field.Expr
}

func (f fileVersion) Table(newTableName string) *fileVersion {
	f.fileVersionDo.UseTable(newTableName)
	return f.updateTableName(newTableName)
}

func (f fileVersion) As(alias string) *fileVersion {
	f.fileVersionDo.DO = *(f.fileVersionDo.As(alias).(*gen.DO))
	return f.updateTableName(alias)
}

func (f *fileVersion) updateTableName(table string) *fileVersion {
	f.ALL = field.NewAsterisk(table)
	f.VersionID = field.NewString(table, "version_id")
	f.FileID = field.NewString(table, "file_id")
	f.VersionNumber = field.NewInt32(table, "version_number")
	f.Size = field.NewInt64(table, "size")
	f.Path = field.NewString(table, "path")
	f.ContentType = field.NewString(table, "content_type")
	f.CreatedAt = field.NewInt64(table, "created_at")
	f.DeletedAt = field.NewInt64(table, "deleted_at")
	f.Status = field.NewInt32(table, "status")
	f.CommitMessage = field.NewString(table, "commit_message")

	f.fillFieldMap()

	return f
}

func (f *fileVersion) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := f.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (f *fileVersion) fillFieldMap() {
	f.fieldMap = make(map[string]field.Expr, 10)
	f.fieldMap["version_id"] = f.VersionID
	f.fieldMap["file_id"] = f.FileID
	f.fieldMap["version_number"] = f.VersionNumber
	f.fieldMap["size"] = f.Size
	f.fieldMap["path"] = f.Path
	f.fieldMap["content_type"] = f.ContentType
	f.fieldMap["created_at"] = f.CreatedAt
	f.fieldMap["deleted_at"] = f.DeletedAt
	f.fieldMap["status"] = f.Status
	f.fieldMap["commit_message"] = f.CommitMessage
}

func (f fileVersion) clone(db *gorm.DB) fileVersion {
	f.fileVersionDo.ReplaceConnPool(db.Statement.ConnPool)
	return f
}

func (f fileVersion) replaceDB(db *gorm.DB) fileVersion {
	f.fileVersionDo.ReplaceDB(db)
	return f
}

type fileVersionDo struct{ gen.DO }

type IFileVersionDo interface {
	gen.SubQuery
	Debug() IFileVersionDo
	WithContext(ctx context.Context) IFileVersionDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IFileVersionDo
	WriteDB() IFileVersionDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IFileVersionDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IFileVersionDo
	Not(conds ...gen.Condition) IFileVersionDo
	Or(conds ...gen.Condition) IFileVersionDo
	Select(conds ...field.Expr) IFileVersionDo
	Where(conds ...gen.Condition) IFileVersionDo
	Order(conds ...field.Expr) IFileVersionDo
	Distinct(cols ...field.Expr) IFileVersionDo
	Omit(cols ...field.Expr) IFileVersionDo
	Join(table schema.Tabler, on ...field.Expr) IFileVersionDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IFileVersionDo
	RightJoin(table schema.Tabler, on ...field.Expr) IFileVersionDo
	Group(cols ...field.Expr) IFileVersionDo
	Having(conds ...gen.Condition) IFileVersionDo
	Limit(limit int) IFileVersionDo
	Offset(offset int) IFileVersionDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IFileVersionDo
	Unscoped() IFileVersionDo
	Create(values ...*model.FileVersion) error
	CreateInBatches(values []*model.FileVersion, batchSize int) error
	Save(values ...*model.FileVersion) error
	First() (*model.FileVersion, error)
	Take() (*model.FileVersion, error)
	Last() (*model.FileVersion, error)
	Find() ([]*model.FileVersion, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FileVersion, err error)
	FindInBatches(result *[]*model.FileVersion, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.FileVersion) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IFileVersionDo
	Assign(attrs ...field.AssignExpr) IFileVersionDo
	Joins(fields ...field.RelationField) IFileVersionDo
	Preload(fields ...field.RelationField) IFileVersionDo
	FirstOrInit() (*model.FileVersion, error)
	FirstOrCreate() (*model.FileVersion, error)
	FindByPage(offset int, limit int) (result []*model.FileVersion, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IFileVersionDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (f fileVersionDo) Debug() IFileVersionDo {
	return f.withDO(f.DO.Debug())
}

func (f fileVersionDo) WithContext(ctx context.Context) IFileVersionDo {
	return f.withDO(f.DO.WithContext(ctx))
}

func (f fileVersionDo) ReadDB() IFileVersionDo {
	return f.Clauses(dbresolver.Read)
}

func (f fileVersionDo) WriteDB() IFileVersionDo {
	return f.Clauses(dbresolver.Write)
}

func (f fileVersionDo) Session(config *gorm.Session) IFileVersionDo {
	return f.withDO(f.DO.Session(config))
}

func (f fileVersionDo) Clauses(conds ...clause.Expression) IFileVersionDo {
	return f.withDO(f.DO.Clauses(conds...))
}

func (f fileVersionDo) Returning(value interface{}, columns ...string) IFileVersionDo {
	return f.withDO(f.DO.Returning(value, columns...))
}

func (f fileVersionDo) Not(conds ...gen.Condition) IFileVersionDo {
	return f.withDO(f.DO.Not(conds...))
}

func (f fileVersionDo) Or(conds ...gen.Condition) IFileVersionDo {
	return f.withDO(f.DO.Or(conds...))
}

func (f fileVersionDo) Select(conds ...field.Expr) IFileVersionDo {
	return f.withDO(f.DO.Select(conds...))
}

func (f fileVersionDo) Where(conds ...gen.Condition) IFileVersionDo {
	return f.withDO(f.DO.Where(conds...))
}

func (f fileVersionDo) Order(conds ...field.Expr) IFileVersionDo {
	return f.withDO(f.DO.Order(conds...))
}

func (f fileVersionDo) Distinct(cols ...field.Expr) IFileVersionDo {
	return f.withDO(f.DO.Distinct(cols...))
}

func (f fileVersionDo) Omit(cols ...field.Expr) IFileVersionDo {
	return f.withDO(f.DO.Omit(cols...))
}

func (f fileVersionDo) Join(table schema.Tabler, on ...field.Expr) IFileVersionDo {
	return f.withDO(f.DO.Join(table, on...))
}

func (f fileVersionDo) LeftJoin(table schema.Tabler, on ...field.Expr) IFileVersionDo {
	return f.withDO(f.DO.LeftJoin(table, on...))
}

func (f fileVersionDo) RightJoin(table schema.Tabler, on ...field.Expr) IFileVersionDo {
	return f.withDO(f.DO.RightJoin(table, on...))
}

func (f fileVersionDo) Group(cols ...field.Expr) IFileVersionDo {
	return f.withDO(f.DO.Group(cols...))
}

func (f fileVersionDo) Having(conds ...gen.Condition) IFileVersionDo {
	return f.withDO(f.DO.Having(conds...))
}

func (f fileVersionDo) Limit(limit int) IFileVersionDo {
	return f.withDO(f.DO.Limit(limit))
}

func (f fileVersionDo) Offset(offset int) IFileVersionDo {
	return f.withDO(f.DO.Offset(offset))
}

func (f fileVersionDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IFileVersionDo {
	return f.withDO(f.DO.Scopes(funcs...))
}

func (f fileVersionDo) Unscoped() IFileVersionDo {
	return f.withDO(f.DO.Unscoped())
}

func (f fileVersionDo) Create(values ...*model.FileVersion) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Create(values)
}

func (f fileVersionDo) CreateInBatches(values []*model.FileVersion, batchSize int) error {
	return f.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (f fileVersionDo) Save(values ...*model.FileVersion) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Save(values)
}

func (f fileVersionDo) First() (*model.FileVersion, error) {
	if result, err := f.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.FileVersion), nil
	}
}

func (f fileVersionDo) Take() (*model.FileVersion, error) {
	if result, err := f.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.FileVersion), nil
	}
}

func (f fileVersionDo) Last() (*model.FileVersion, error) {
	if result, err := f.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.FileVersion), nil
	}
}

func (f fileVersionDo) Find() ([]*model.FileVersion, error) {
	result, err := f.DO.Find()
	return result.([]*model.FileVersion), err
}

func (f fileVersionDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FileVersion, err error) {
	buf := make([]*model.FileVersion, 0, batchSize)
	err = f.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (f fileVersionDo) FindInBatches(result *[]*model.FileVersion, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return f.DO.FindInBatches(result, batchSize, fc)
}

func (f fileVersionDo) Attrs(attrs ...field.AssignExpr) IFileVersionDo {
	return f.withDO(f.DO.Attrs(attrs...))
}

func (f fileVersionDo) Assign(attrs ...field.AssignExpr) IFileVersionDo {
	return f.withDO(f.DO.Assign(attrs...))
}

func (f fileVersionDo) Joins(fields ...field.RelationField) IFileVersionDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Joins(_f))
	}
	return &f
}

func (f fileVersionDo) Preload(fields ...field.RelationField) IFileVersionDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Preload(_f))
	}
	return &f
}

func (f fileVersionDo) FirstOrInit() (*model.FileVersion, error) {
	if result, err := f.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.FileVersion), nil
	}
}

func (f fileVersionDo) FirstOrCreate() (*model.FileVersion, error) {
	if result, err := f.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.FileVersion), nil
	}
}

func (f fileVersionDo) FindByPage(offset int, limit int) (result []*model.FileVersion, count int64, err error) {
	result, err = f.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = f.Offset(-1).Limit(-1).Count()
	return
}

func (f fileVersionDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = f.Count()
	if err != nil {
		return
	}

	err = f.Offset(offset).Limit(limit).Scan(result)
	return
}

func (f fileVersionDo) Scan(result interface{}) (err error) {
	return f.DO.Scan(result)
}

func (f fileVersionDo) Delete(models ...*model.FileVersion) (result gen.ResultInfo, err error) {
	return f.DO.Delete(models)
}

func (f *fileVersionDo) withDO(do gen.Dao) *fileVersionDo {
	f.DO = *do.(*gen.DO)
	return f
}
